= Distributed Object Events
[[distributed-object-events]]

== Listening for Map Events

You can listen to map-level or entry-based events using the listeners provided by the Hazelcast's eventing framework. To listen to these events, you will 
implement `MapListener`. This interface provide both map-level and entry-level listeners. A map-level event is triggered by a map-level operation, e.g. `IMap.clear()` or `IMap.evictAll()`. An entry-based event is triggered by operations that affect a specific entry, e.g., `IMap.remove()` or `IMap.evict()`.

NOTE: Hazelcast versions prior to 4.0 used the `EntryListener` interface to monitor entry-level events. While this interface is still available for backwards-compatibility reasons, you should use `MapListener` and its associated operations when writing new listeners for map events. 


Here are the listener sub-interfaces for `MapListener`. 

[cols="1,1"]
|===
| `EntryAddedListener`
|Triggered when an entry is added to the map.

|`EntryEvictedListener`
|Triggered when an entry is removed from the map due to size-based eviction. See the xref:data-structures:map.adoc#map-eviction[Map Eviction section] for more information. 

|`EntryExpiredListener`
|Triggered when an entry is removed from the map due to expiration-based eviction (happens when time-to-live and/or maximum idle seconds are configured
for the entries). If your listener implements both this one and `EntryEvictedListener` together, the listener may receive both expiration and eviction events for the same entry. Size-based eviction removes entries regardless of whether entries are expired or not.
|`EntryLoadedListener`
|Triggered when an entry is loaded by a `MapLoader` implementation.

|`EntryMergedListener`
|Triggered when a WAN-replicated entry is merged.

|`EntryRemovedListener`
|Triggered when an entry is directly removed from the map, for example using the `map.remove()` method or the REST `DELETE` xref:clients:rest.adoc#removing-entries-from-a-map-for-rest-client[call].

|`EntryUpdatedListener`
|Triggered when an entry is updated.

|`EventLostListener`
|Triggered when events are lost.

|`MapClearedListener`
|Triggered when all the entries of a map are removed using the `map.clear()` method.

|`MapEvictedListener`
|Triggered when all the entries of a map are removed using the `map.evictAll()` method.

|`MapPartitionLostListener`
|Triggered when the owner and all backups of a partition are lost for a specific map. See the <<listening-for-lost-map-partitions, Listening for Lost Map Partitions section>> for details.
|===

=== Catching a Map Event

To catch an event, you should explicitly implement a corresponding sub-interface of a `MapListener`,
such as `EntryAddedListener` or `MapClearedListener`.

Let's take a look at the following class example.

[tabs] 
==== 
Java:: 
+ 
--
[source,java]
----
include::{javasource}/distributedevents/Listen.java[tag=listen]

----
--
C++:: 
+
--
[source,cpp]
----


----
--

C Sharp:: 
+
-- 
[source,cs]
----

----
--

Node.js:: 
+ 
-- 
[source,javascript]
----

----
--
Python:: 
+ 
-- 
[source,python]
----

----
--
Go:: 
+ 
-- 
[source,go]
----
// error handling is omitted for brevity
	ctx := context.TODO()
	client, _ := hazelcast.StartNewClient(ctx)
	entryListenerConfig := hazelcast.MapEntryListenerConfig{
		IncludeValue: true,
	}
	m, _ := client.GetMap(ctx, "somemap")
	entryListenerConfig.NotifyEntryAdded(true)
	entryListenerConfig.NotifyEntryRemoved(true)
	entryListenerConfig.NotifyEntryUpdated(true)
	entryListenerConfig.NotifyEntryEvicted(true)
	entryListenerConfig.NotifyEntryLoaded(true)

	m.AddEntryListener(ctx, entryListenerConfig, func(event *hazelcast.EntryNotified) {
		switch event.EventType {
		case hazelcast.EntryAdded:
			fmt.Println("Entry Added:", event)
		case hazelcast.EntryRemoved:
			fmt.Println("Entry Removed:", event)
		case hazelcast.EntryUpdated:
			fmt.Println("Entry Updated:", event)
		case hazelcast.EntryEvicted:
			fmt.Println("Entry Remove:", event)
		case hazelcast.EntryLoaded:
			fmt.Println("Entry Loaded:", event)
		}
	})
----
--
====


Now, let's perform some modifications on the map entries using the following example code.

[tabs] 
==== 
Java:: 
+ 
--
[source,java]
----
include::{javasource}/distributedevents/ModifyMap.java[tag=modify]

----
--
C++:: 
+
--
[source,cpp]
----


----
--

C Sharp:: 
+
-- 
[source,cs]
----

----
--

Node.js:: 
+ 
-- 
[source,javascript]
----

----
--
Python:: 
+ 
-- 
[source,python]
----

----
--
Go:: 
+ 
-- 
[source,go]
----
	// performing modifications on the map entries
	key := strconv.Itoa(int(time.Now().Unix()))
	m.Put(ctx, key, "1")
	m.Put(ctx, key, "2")
	m.Delete(ctx, key)

----
--
====


If you execute the `Listen` class and then the `Modify` class, you get the following output
produced by the `Listen` class.

```
Entry Added:EntryEvent{entryEventType=ADDED, member=Member [192.168.1.100]]:5702
 - ffedb655-bbad-43ea-aee8-d429d37ce528, name='somemap', key=11455268066242,
 oldValue=null, value=1, mergingValue=null}

Entry Updated:EntryEvent{entryEventType=UPDATED, member=Member [192.168.1.100]]:5702
 - ffedb655-bbad-43ea-aee8-d429d37ce528, name='somemap', key=11455268066242,
 oldValue=1, value=2, mergingValue=null}

Entry Removed:EntryEvent{entryEventType=REMOVED, member=Member [192.168.1.100]]:5702
 - ffedb655-bbad-43ea-aee8-d429d37ce528, name='somemap', key=11455268066242,
 oldValue=null, value=null, mergingValue=null}
```

NOTE: Please note that the method `IMap.clear()` does not fire an
"EntryRemoved" event, but fires a "MapCleared" event.

NOTE: Listeners have to offload all blocking operations to another thread (pool).


== Listening for Lost Map Partitions

You can listen to `MapPartitionLostEvent` instances by registering an implementation of `MapPartitionLostListener`, which is also a sub-interface of `MapListener`.

Let's consider the following example code:

[source,java]
----
include::{javasource}/distributedevents/ListenMapPartitionLostEvents.java[tag=lmple]
----

Within this example code, a `MapPartitionLostListener` implementation is registered to a map that is configured with one backup. For this particular map and any of the partitions in the system, if the partition owner member and its first backup member crash simultaneously, the
given `MapPartitionLostListener` receives a corresponding `MapPartitionLostEvent`. If only a single member crashes in the cluster, there is no `MapPartitionLostEvent` fired for this map since backups for the partitions owned by the crashed member are kept on other members.

See the xref:cluster-events.adoc#listening-for-partition-lost-events[Listening for Partition Lost Events section] for more
information about partition lost detection and partition lost events.

[[registering-map-listeners]]
=== Registering Map Listeners

After you create your listener class, you can configure your cluster
to include map listeners using the method `addEntryListener` (as you
can see in the example `Listen` class above). Below is the related portion
from this code, showing how to register a map listener.

[source,java]
----
HazelcastInstance hz = Hazelcast.newHazelcastInstance();
IMap<String, String> map = hz.getMap( "somemap" );
map.addEntryListener( new MyEntryListener(), true );
----

With the above approach, there is the possibility of missing events
between the creation of the instance and registering the listener.
To overcome this race condition, Hazelcast allows you to register
listeners in configuration. You can register listeners using declarative,
programmatic, or Spring configuration, as shown below.

The following is an example programmatic configuration.

[source,java]
----
mapConfig.addEntryListenerConfig(
new EntryListenerConfig( "com.yourpackage.MyEntryListener",
                                 false, false ) );
----


The following is an example of the equivalent declarative configuration.

[tabs] 
==== 
XML:: 
+ 
-- 
[source,xml]
----
<hazelcast>
    ...
    <map name="somemap">
        <entry-listeners>
            <entry-listener include-value="false" local="false">
                com.yourpackage.MyEntryListener
            </entry-listener>
        </entry-listeners>
    </map>
    ...
</hazelcast>
----
--

YAML::
+
--
[source,yaml]
----
hazelcast: 
  map:
    somemap:
      entry-listeners:
        - class-name: com.your-package.MyEntryListener
          include-value: false
          local: false
----
--

Spring::
+
[source,xml]
----
<hz:map name="somemap">
    <hz:entry-listeners>
        <hz:entry-listener include-value="true"
            class-name="com.hazelcast.spring.DummyEntryListener"/>
        <hz:entry-listener implementation="dummyEntryListener" local="true"/>
    </hz:entry-listeners>
</hz:map>
----
====

=== Map Listener Attributes

As you see, there are attributes of the map listeners in the above
examples: `include-value` and `local`. The attribute `include-value`
is a boolean attribute that is optional, and if you set it to `true`,
the map event contains the map value. Its default value is `true`.

The attribute `local` is also a boolean attribute that is optional, and
if you set it to `true`, you can listen to the map on the local member.
Its default value is `false`.

== Listening for MultiMap Events

You can listen to entry-based events in the MultiMap using `EntryListener`.
The following is an example entry listener implementation for MultiMap.

[source,java]
----
include::{javasource}/distributedevents/ExampleEntryListener.java[tag=mm]
----

=== Registering MultiMap Listeners

After you create your listener class, you can configure your cluster to
include MultiMap listeners using the method `addEntryListener`. Below
is the related portion from a code, showing how to register a map listener.

[source,java]
----
HazelcastInstance hz = Hazelcast.newHazelcastInstance();
MultiMap<String, String> map = hz.getMultiMap( "somemap" );
map.addEntryListener( new ExampleEntryListener(), true );
----

With the above approach, there is the possibility of missing events
between the creation of the instance and registering the listener.
To overcome this race condition, Hazelcast allows you to register
listeners in the configuration. You can register listeners using declarative,
programmatic, or Spring configuration, as shown below.

The following is an example programmatic configuration.

[source,java]
----
multiMapConfig.addEntryListenerConfig(
  new EntryListenerConfig( "com.yourpackage.ExampleEntryListener",
    false, false ) );
----

The following is an example of the equivalent declarative configuration.

[tabs] 
==== 
XML:: 
+ 
-- 
[source,xml]
----
<hazelcast>
    ...
    <multimap name="somemap">
        <value-collection-type>SET</value-collection-type>
        <entry-listeners>
            <entry-listener include-value="false" local="false">
                com.yourpackage.ExampleEntryListener
            </entry-listener>
        </entry-listeners>
    </multimap>
    ...
</hazelcast>
----
--

YAML::
+
--
[source,yaml]
----
hazelcast:
  multimap:
    somemap:
      value-collection: SET
      entry-listeners:
        - class-name: com.your-package.MyEntryListener
          include-value: false
          local: false
----
--

Spring::
+
[source,xml]
----
<hz:multimap name="somemap" value-collection-type="SET">
    <hz:entry-listeners>
        <hz:entry-listener include-value="false"
            class-name="com.yourpackage.ExampleEntryListener"/>
        <hz:entry-listener implementation="EntryListener" local="false"/>
    </hz:entry-listeners>
</hz:multimap>
----
====

=== MultiMap Listener Attributes

As you see, there are attributes of the MultiMap listeners in the above
examples: `include-value` and `local`. The attribute `include-value` is
a boolean attribute that is optional, and if you set it to `true`, the
MultiMap event contains the map value. Its default value is `true`.

The attribute `local` is also a boolean attribute that is optional, and
if you set it to `true`, you can listen to the MultiMap on the local member.
Its default value is `false`.


== Listening for Item Events

The Item Listener is used by the Hazelcast `IQueue`, `ISet` and `IList` interfaces.

To write an Item Listener class, you implement the ItemListener
interface and its methods `itemAdded` and `itemRemoved`. These methods
are invoked when an item is added or removed.

The following is an example Item Listener class for an `ISet` structure.

[source,java]
----
public class ExampleItemListener implements ItemListener<Price> {

    @Override
    public void itemAdded(ItemEvent<Price> event) {
        System.out.println( "Item added:  " + event );
    }

    @Override
    public void itemRemoved(ItemEvent<Price> event) {
        System.out.println( "Item removed: " + event );
    }
}
----

NOTE: You can use `ICollection` when creating any of the collection
(queue, set and list) data structures, as shown above. You can also
use `IQueue`, `ISet` or `IList` instead of `ICollection`.

=== Registering Item Listeners

After you create your class, you can configure your cluster to include
item listeners. Below is an example using the method `addItemListener`
for `ISet` (it applies also to `IQueue` and `IList`). You can also see
this portion in the above class creation.

[source,java]
----
HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();

ICollection<Price> set = hazelcastInstance.getSet( "default" );
// or ISet<Prices> set = hazelcastInstance.getSet( "default" );
set.addItemListener( new ExampleItemListener(), true );
----

With the above approach, there is the possibility of missing events
between the creation of the instance and registering the listener.
To overcome this race condition, Hazelcast allows you to register
listeners in the configuration. You can register listeners using
declarative, programmatic, or Spring configuration, as shown below.

The following is an example programmatic configuration.

[source,java]
----
setConfig.addItemListenerConfig(
new ItemListenerConfig( "com.yourpackage.ExampleItemListener", true ) );
----


The following is an example of the equivalent declarative configuration.

[tabs] 
==== 
XML:: 
+ 
-- 
[source,xml]
----
<hazelcast>
    ...
    <set>
        <item-listeners>
            <item-listener include-value="true">
                com.yourpackage.ExampleItemListener
            </item-listener>
        </item-listeners>
    </set>
    ...
</hazelcast>
----
--

YAML::
+
--
[source,yaml]
----
hazelcast:
  set:
    default:
      item-listeners:
        - class-name: com.yourpackage.ExampleItemListener
          include-value: true
----
--

Spring::
+
[source,xml]
----
<hz:set name="default" >
    <hz:item-listeners>
        <hz:item-listener include-value="true"
            class-name="com.yourpackage.ExampleItemListener"/>
    </hz:item-listeners>
</hz:set>
----
====

=== Item Listener Attributes

As you see, there is an attribute in the above examples: `include-value`.
It is a boolean attribute that is optional, and if you set it to `true`,
the item event contains the item value. Its default value is `true`.

There is also another attribute called `local`, which is not shown in the
above examples. It is also a boolean attribute that is optional, and
if you set it to `true`, you can listen to the items on the local member.
Its default value is `false`.

== Listening for Topic Messages

The Message Listener is used by the `ITopic` interface. It notifies
when a message is received for the registered topic.

To write a Message Listener class, you implement the MessageListener
interface and its method `onMessage`, which is invoked
when a message is received for the registered topic.

The following is an example Message Listener class.

[source,java]
----
public class ExampleMessageListener implements MessageListener<MyEvent> {

    public void onMessage( Message<MyEvent> message ) {
        MyEvent myEvent = message.getMessageObject();
        System.out.println( "Message received = " + myEvent.toString() );
    }
}
----

=== Registering Message Listeners

After you create your class, you can configure your cluster to include
message listeners. Below is an example using the method `addMessageListener`.

[source,java]
----
HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();

ITopic topic = hazelcastInstance.getTopic( "default" );
topic.addMessageListener( new ExampleMessageListener() );
----

With the above approach, there is the possibility of missing messaging
events between the creation of the instance and registering the listener.
To overcome this race condition, Hazelcast allows you to register this
listener in the configuration. You can register it using declarative,
programmatic, or Spring configuration, as shown below.

The following is an example programmatic configuration.

[source,java]
----
topicConfig.addMessageListenerConfig(
  new ListenerConfig( "com.yourpackage.ExampleMessageListener" ) );
----

The following is an example of the equivalent declarative configuration.

[tabs] 
==== 
XML:: 
+ 
-- 
[source,xml]
----
<hazelcast>
    ...
    <topic name="default">
        <message-listeners>
            <message-listener>
                com.yourpackage.ExampleMessageListener
            </message-listener>
        </message-listeners>
    </topic>
    ...
</hazelcast>
----
--

YAML::
+
--
[source,yaml]
----
hazelcast:
  topic:
    default:
      message-listeners:
        - com.yourpackage.ExampleMessageListener
----
--

Spring::
+
[source,xml]
----
<hz:topic name="default">
    <hz:message-listeners>
        <hz:message-listener
            class-name="com.yourpackage.ExampleMessageListener"/>
    </hz:message-listeners>
</hz:topic>
----
====