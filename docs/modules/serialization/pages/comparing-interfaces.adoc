= Comparing Serialization Interfaces

The table below provides a comparison between the interfaces listed in the previous section
to help you in deciding which interface to use in your applications.

[cols="3m,4a,3a,4a"]
|===
| Serialization Interface| Supported Clients|Advantages| Disadvantages

| Serializable
| Members and Java clients
| * A standard and basic Java interface

* Requires no implementation
| * More time and CPU usage

* More space occupancy

| Externalizable
| Members and Java clients
| * A standard Java interface

* More CPU and memory usage efficient than `Serializable`
| * Serialization interface must be implemented

| DataSerializable
| Members and Java clients
| * More CPU and memory usage efficient than `Serializable`
| * Specific to Hazelcast

| IdentifiedDataSerializable
| Members and all clients
| * More CPU and memory usage efficient than `Serializable`

* Reflection is not used during deserialization

| * Specific to Hazelcast

* You must implement this serialization interface

* A Factory and configuration must be implemented

| Portable
| Members and all clients
| * More CPU and memory usage efficient than `Serializable`

* Reflection is not used during deserialization

* Versioning is supported

* Faster queries than `Custom Serialization` thanks to partial deserialization support during queries

| * Specific to Hazelcast

* You must implement this serialization interface

* A Factory and configuration must be implemented

* Class definition is also sent with data but stored only once per class

| Custom Serialization
|Members and all clients
| * Does not require class to implement an interface

* Can be based on `StreamSerializer` `ByteArraySerializer`

|* You must implement your own serializer

* Slower queries compared to `Portable` because partial deserialization is not supported for queries

* Requires a plugin and configuration
|===